# 字典

~~~markdown
字典：（dict）
	生活中的字典：通过目录查找内容   
	编程中的字典：通过键查找值
		字典是一种映射，hash（哈希）
语法：
key：键
value:值
key-value：键值对   （项，k-v，entry）

字典：是python中唯一的映射类型

字典的特点：
1. 不支持下标操作
2. 字典是无序的
3. 字典的键是唯一的
~~~

~~~python
phone_ch=['华为','小米','联想','天宇']
phone_en=['Huawei','MI','lenovo','Tianyu']

# 打印中文的手机名和对应的英文名
print(phone_ch[1],phone_en[phone_ch.index(phone_ch[1])])

phones={'华为':'Huawei','小米':'MI','联想':'lenovo','天宇':'Tianyu'}
print(phones['小米'])

~~~

* 字典的创建

~~~markdown
结构：
变量名={键1:值1，键2：值2，...}

1. dict():
		返回空字典
		空字典：{}
2. dict(mapping):
		mapping:可以替代映射关系即可
		
		{1:'one',2:'two',3:'three'}
		利用映射关系创建字典
3. dict(iterable):
		iterable:表示出映射关系，底层利用的遍历和序列赋值，for循环的参数有两个（元组）
		[(1,'one'),(2,'two'),(3,'three')]
4. dict(**kwargs)：
		只能用关键字参数传值
		关键字参数会被打包成字典输出
		注意：数字不能作为关键字，所以字典如果想要使用数字所谓键，不能使用该构造方法
		
5. 手工创建：
		空字典：{}
		一般字典：{1: 'one', 2: 'two', 3: 'three'}
		
6. 利用方法创建：
		fromkeys(iterable, value=None)
		是字典中的一个方法
		{}.fromkeys()
		iterable中的元素作为每一个键
		value值得整体作为键的值（每一个键的值都相等）
~~~

* 字典的访问：

~~~markdown
1. 查看一个键值对
		字典名[键]--->对应的值  （最常用）
2. 查看所有键：
		1. keys()
				返回一个类（类似）集合对象
				对象中的每一个元素都是字典的每一个键
		2. 直接遍历
				字典中只有键，遍历时只能遍历出键
3. 查看所有的值：
		values()：
				返回字典所有的值，被打包成一个类集合对象
4. 查看所有的键值对：
		items():
				返回一个类集合对象，每一个元素都是一个键值对（元组形式）
5. get（k[,d]）：
		k:key
		d:default
		如果字典中有对应项，则返回k对应的值
		如果字典中没有对应的项，则返回None
6. 如果直接访问不存在的键，则会报错：KeyError
~~~

* 修改字典

~~~markdown
1. 手工修改：
		通过键直接对值进行修改
		字典名[键名]=新值
2. 手工添加：
		字典名[新键名]=值
3. clear():
		清空字典
4. pop(k,[d]):
		从字典中删除k对应的键值对，并返回对应的值
		如果键不存在则返回d，如果d没给出则报错
5. popitem()：
		删除并返回某个键值对，如果字典为空，则抛出异常
6. setdefault(k[,d]）：
		d:默认值，作为字典中的值
		如果键在字典中，则返回字典对应的值
		如果键不再字典中，则给字典添加一个键值对，键为k，值为d,并返回d
		d默认为None
7. update([E, ]**F)：
		如果E为字典，则将E中的键值对更新到现在的字典中
		如果E为可迭代对象，则可迭代对象中必须体现映射关系，并将映射关系更新到字典中
		如果E未给出，可以使用F传值，F只接受关键字参数，则F将关键字参数打包成字典并将键值对更新到字典中
~~~

* 字典的方法：

~~~markdown
1. copy（）：
		浅拷贝
~~~

---

